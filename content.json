{"posts":[{"title":"彻底搞清 JavaScript Promise","text":"基本用法我们知道，一个 js Promise 对象，我们可以用 then()、catch()、finally() 进行链式操作，如： 1234567promiseObj.then((res) =&gt; { // do something}).catch((error) =&gt; { // do something}).finally(() =&gt; { // do something}) 这是 js Promise 的基本使用，但是要用好 Promise，还有一下几个问题需要搞清楚。 怎样创建 Promise 对象用 Promise 对象创建 Promise 实例123456789// 创建 Promise 对象const promiseObj = new Promise((resolve, reject) =&gt; { // 这里执行你的业务逻辑 if (fail) { return reject('执行失败参数'); } return resolve('执行成功参数');}); 用 async 创建 Promise 实例async 函数返回一个 Promise 实例，我们可以用来创建 Promise 实例。 12345678910111213141516171819202122async function prm () { // throw new Error('出错了1'); // 如果不正常，抛出错误，触发 catch() 方法，并把此错误实例传参给 catch() return 100; // 正常，返回值传参给第一个 then() 方法}prm().then(res =&gt; { // do something}).catch(err =&gt; { // do something});// 用匿名函数立即执行函数体创建实例const x = (async () =&gt; { // throw new Error('出错了1'); // 如果不正常，抛出错误，触发 catch() 方法，并把此错误实例传参给 catch() return 100; // 正常，返回值传参给第一个 then() 方法})();x.then(res =&gt; { // do something}).catch(err =&gt; { // do something}); 链式调用时参数是怎样传递的then() 参数的传递1234567891011121314// 创建 Promise 对象const promiseObj = new Promise(resolve =&gt; { return resolve(0);});promiseObj.then((res) =&gt; { console.log(1, res); // 1, 0 return 1;}).then((res) =&gt; { console.log(2, res); // 2, 1 return 2;}).then((res) =&gt; { console.log(3, res); // 3, 2 return 3;}) 执行上面的代码，我们发现，第1个 then() 的参数是 resolve() 的参数值，第2个 then() 及之后的 then() 的参数值都是其上一个 then() 的返回值。 catch() 参数的传递catch() 参数的传递和 then() 不同，要把错误从 catch() 传给下一个 catch()，需要在 catch() 中抛出错误。 12345678910111213141516171819202122232425262728293031323334353637Promise.resolve().then(() =&gt; { console.log(1); throw new Error('err');}).catch((err) =&gt; { console.log(2); // throw err; return 'err...'; // catch 中没有抛出错误，返回值将传给下一个 then()}).catch(() =&gt; { console.log(3);}).then(res =&gt; { console.log(4); console.log(res);});// 结果：// 1// 2// 4// err...Promise.resolve().then(() =&gt; { console.log(1); throw new Error('err');}).catch((err) =&gt; { console.log(2); throw err; // return 'err...';}).catch(() =&gt; { console.log(3);}).then(res =&gt; { console.log(4); console.log(res);});// 结果：// 1// 2// 3// 4 在 then() 中怎样传值给上级代码块js Promise 是异步的，同一个 Promise 的 then() 方法是按代码顺序的一个 then 到下一个 than 的执行，但和than 外部的代码块是异步的。如果要把 then 代码块的值传给上层的代码块，回调是常用的方法，但如果上层代码块还需要返回异代码块中的值的时候，回调就做不到了。 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先等待，等到该处的异步操作完成，再接着执行函数体内后面的语句。 123456789101112131415161718const prm = new Promise((resolve, reject) =&gt; { resolve();});let a = 11;prm.then(res =&gt; { // 这里是异步的，后面的代码和这里分两路同时执行 a = 22;});console.log(a); // 11async function test () { let a = 11; await prm.then(res =&gt; { // 这里加了 await，告诉后面的代码说先等等，我这个代码块执行完了你再继续。 a = 22; }); console.log(a); // 22}test(); 注意1、await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。 123456789101112131415async function myFunction() { try { await somethingThatReturnsAPromise(); } catch (err) { console.log(err); }}// 另一种写法async function myFunction() { await somethingThatReturnsAPromise() .catch(function (err) { console.log(err); });} 2、多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 12let foo = await getFoo();let bar = await getBar(); 上面代码中，getFoo 和 getBar 是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有 getFoo 完成以后，才会执行 getBar，完全可以让它们同时触发。 1let [foo, bar] = await Promise.all([getFoo(), getBar()]); 3、await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。从 ES2022 开始允许 await 可以在顶层使用，不需要在 async 函数中。 参考： ECMAScript 6 入门","link":"/front-end/chedigaoqing-javascript-promise.html"},{"title":"JavaScript 箭头函数与 function 函数的区别","text":"见过箭头函数后，知道箭头函数是 function 定义函数的简写，然后还有一点是箭头函数中的 this 是上级代码的 this。其实除了这两点外，箭头函数和 function 函数还有很多区别。 1、基本语法123456789101112// 没有参数时() =&gt; { // code ...}// 有参数时(param1, param2, ..., paramN) =&gt; { // code ...}// 只有1个参数时，圆括号可以省略param =&gt; { // code ...} 2、this 指向 在顶级代码中， this 指向 window 对象； 在 function 定义的函数中， this 指向该函数的对象； 在箭头函数中，箭头函数不会创建自己的 this，始终指向箭头函数所在作用域下的 this。 用原型方法 apply()、call()、bind() 不能改变箭头函数中 this 的指向。 1234567891011121314const bar = { name: 'johnny'};function foo () { console.log(this.name);}const fa = () =&gt; { console.log(this.name);};// bar 作为 foo() 实例的 thisfoo.call(bar); // johnnyfa.call(bar); // TypeError: Cannot read properties of undefined (reading 'name') 3、箭头函数不能做构造函数不可以使用 new 命令创建箭头函数实例对象，因为箭头函数没有自己的 this，不能调用 call()、apply。箭头函数没有 prototype 属性，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 __proto__属性。 123456789function fn() { console.log(11)}const f = new fn();const fa = () { console.log(22)}new fa(); // TypeError: fa is not a constructor 4、箭头函数没有 arguments 对象1234567891011121314function fn() { console.log(arguments);}fn(1, 2, 3) // [Arguments] { '0': 1, '1': 2, '2': 3 }const fa = () =&gt; { console.log(arguments); // undefined}// 使用展开运算符 … 来实现类似 arguments 的调用，缺点是只有一个参数名。let fa2 = (...args) =&gt;{ console.log(args)}fa2(1, 2, 3) // [ 1, 2, 3 ] 5 对象属性的箭头函数对象属性的箭头函数中的 this 并不是指向该对象，而是指向该对象的上一层。 12345678910111213141516171819202122232425function fn () { this.a = 123; const obj = { a: 10, b: function () { console.log(this); // { a: 10, b: [Function: b], c: [Function: c], d: [Function: d] } console.log(this.a); // 10 }, c: () =&gt; { console.log('c this', this); // 指向 fn 函数的实例 console.log('c this.a', this.a); // 123 }, // 定义对象 function 的简写形式 d () { } }; obj.b(); obj.c();}new fn(); 不可以使用 yield 命令因为不可以使用 yield 命令，箭头函数不能用作 Generator 函数。 总结箭头函数不是 没有 this 的 function 函数，并不能替代 function 函数，箭头函数更适用于需要匿名函数的地方。建议定义顶级函数的时候不用箭头函数，而是用 function 来定义。","link":"/front-end/javascript-arrow-function.html"},{"title":"elx-imgbox 前端图片选取和上传插件","text":"一个基于element-ui，实现图片选取和上传的Vue插件，可显著提升管理后台图片选取、上传的用户体验。 源码： https://github.com/yibafun/elx-imgbox 效果截图1、选取图片库中的图片 2、上传图片 require Vue 2.5+ element-ui 2+ jQuery 使用方法1、引入依赖前端库123456&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/element-ui/2.0.5/theme-chalk/index.css&quot;&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.8/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/element-ui/2.0.5/index.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- elx-imgbox 直接引用GitHub上的文件，你可以下载到本地再引用 --&gt;&lt;script src=&quot;https://raw.githubusercontent.com/erzh/elx-imgbox/master/dist/imgbox.js&quot;&gt;&lt;/script&gt; 2、在原生js或Vue代码中调用12345678910111213141516171819202122// 参数设置var opts = { uploadUrl: 'http://imgbox.imcm.me/test/upload.json', listUrl: 'http://imgbox.imcm.me/test/list.json', onSelect: function(img){ // 选中图片后回调处理，每个图片回调一次 console.log(img); }};// 调用功能，var imgbox = Vue.elxImgbox(opts);options{ uploadUrl: '', // 图片上传URL listUrl: '', // 图片列表数据URL multiple: true, // 是否支持选取多个图片 limit: 10, // 一批次最多可上传图片数 onSelect: null, // 选择后回调函数 enableUpload: true, // 是否启用图片上传 maxSize: 2 // 最大尺寸（M）} 关于上传 支持选择单个文件和多个文件； 选择文件后，需要点击“确定上传”开始上传图片； 上传图片只要有一张成功则回调并关闭上传窗口 有错误发生ELEMENT.Message.error()提示 交互数据上传返回数据格式1234567{ &quot;uploadfile_response&quot;: { &quot;name&quot;:&quot;图片名&quot;, &quot;thumb&quot;:&quot;图片缩略图链接&quot;, &quot;你需要的其他属性&quot;: &quot;其他属性值&quot; }} 列表数据格式123456789101112{ &quot;list&quot;:[ { &quot;name&quot;: &quot;图片名&quot;, &quot;thumb&quot;: &quot;图片缩略图链接&quot;, &quot;label&quot;: &quot;图片长x宽&quot;, &quot;你需要的其他属性&quot;: &quot;其他属性值&quot; } ], &quot;total&quot;: &quot;总图片数&quot;}","link":"/front-end/element-ui-imgbox.html"},{"title":"JavaScript 原型方法：call、apply、bind","text":"call、apply、bind 是 JavaScript 函数的原型方法，用于改变函数的 this 指向来执行函数。一般这种鬼操作能不用则不用，没得选的时候才有必要用。 apply() 调用一个具有给定 this 值的函数，以及以一个数组（或一个类数组对象的形式提供的参数 call() 使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数 bind() 创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用 123456789101112131415const bar = { name: 'johnny'};function foo (age, hobby) { console.log(this.name, age, hobby);}// apply 和 call 作用相同，传参方式不同foo.apply(bar, [28, 'sleep']); // johnny 28 sleepfoo.call(bar, 28, 'sleep'); // johnny 28 sleep// 先绑定对象返回一个函数const bindBar = foo.bind(bar);bindBar(28, 'sleep'); // johnny 28 sleep 参考：深入理解JavaScript——call、apply、bind三大将","link":"/front-end/javascript-prototype-method-call-apply-bind.html"},{"title":"用可变变量访问 JavaScript 对象方法和类静态方法遇到的 this undefined 的问题","text":"JavaScript中，用可变变量访问对象方法或类静态方法，如果访问的方法中 this，此时 this 将会是 undefined。我们用类名/对象变量名代替 this 就能解决了。 123456789101112131415161718192021222324252627282930313233343536373839class Cls { static f1 () { this.f0(); } static f2 () { Cls.f0(); } static f0 () { console.log('Test f0'); }}const Obj = { f1 () { this.f0(); }, f2 () { Obj.f0(); }, f0 () { console.log('Obj f0'); }};// 用变量函数调用const clsF1 = Cls.f1;clsF1(); // this 为 undefinedconst clsF2 = Cls.f2;clsF2(); // 正常const objF1 = Obj.f1;objF1(); // this 为 undefinedconst objF2 = Obj.f2;objF2(); // 正常","link":"/front-end/javascript-class-static-method-as-variable-variables.html"},{"title":"Vue3 组件间相互访问（单文件 + &lt;script setup&gt; + 组合式 API 举例）","text":"父组件传参数到子组件 - props在 &lt;script setup&gt; 中用 defineProps() 声明组件的属性，在父组件模板中引用子组件时，就可以给通过属性给子组件传参数（可以是值、变量、函数、对象等）。 defineProps 是编译器宏，Vue3 编译器宏不需要导入，并且只能在 &lt;script setup&gt; 中使用。 ex: 子组件声明、调用属性 12345678910111213&lt;!-- HelloWorld.vue 子组件--&gt;&lt;script setup&gt;// 声明属性defineProps([{ msg: String}])&lt;/script&gt;&lt;template&gt; &lt;div&gt; {{ msg }} &lt;/div&gt;&lt;/template&gt; ex: 父组件使用属性 12345678&lt;!-- Demo.vue 父组件 --&gt;&lt;script setup&gt;import HelloWorld from './HelloWorld.vue'&lt;/script&gt;&lt;template&gt; &lt;HelloWorld msg=&quot;Welcome&quot;/&gt;&lt;/template&gt; 父组件传递事件到子组件在 &lt;script setup&gt; 中用编译器宏 defineEmits() 声明组件提供的事件，并且触发事件后，在父组件引用子组件时就可以给子组件传递事件。 模板中用可直接用 $emit 变量触发事件，不需要用 defineEmits() 声明，但是实现触发事件的同时还需要做其他事情时，就要用 defineEmits()。 ex: 子组件声明 &amp; 触发事件 12345678910111213141516171819202122232425&lt;!-- HelloWorld.vue 子组件--&gt;&lt;script setup&gt;// 声明事件const emits = defineEmits(['my-event-a', 'myEventB'])const onEventA = () =&gt; { // 触发事件 emits('my-event-a'); // more code}const onEventB = () =&gt; { // 触发事件，并给事件传参 emits('my-event-b', '参数1', '参数2', '参数...'); // more code}&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;$emit('my-event-1')&quot;&gt;$emit 触发事件&lt;/button&gt; &lt;button @click=&quot;$emit('my-event-2', '参数1', '参数2')&quot;&gt;$emit 触发事件并传参&lt;/button&gt; &lt;button @click=&quot;onEventA&quot;&gt;按钮a&lt;/button&gt; &lt;button @click=&quot;onEventB&quot;&gt;按钮b&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; ex: 父组件传递事件到子组件 123456789101112131415&lt;!-- Demo.vue 父组件 --&gt;&lt;script setup&gt;import HelloWorld from './HelloWorld.vue';const handle1 = () =&gt; { console.log('hi')}const handle2 = (arg1, arg2) =&gt; { console.log(arguments)}&lt;/script&gt;&lt;template&gt; &lt;HelloWorld msg=&quot;Welcome&quot; @my-event-1=&quot;handle1&quot; @my-event-2=&quot;handle2&quot; @my-event-a=&quot;handle1&quot; @my-event-b=&quot;handle2&quot; /&gt;&lt;/template&gt; 父组件通过插槽给子组件分配内容使用 &lt;slot /&gt; 作为一个占位符，父组件传递进来的内容就会渲染在这里。 1234567&lt;!-- AlertBox.vue 子组件 --&gt;&lt;template&gt; &lt;div class=&quot;alert-box&quot;&gt; &lt;strong&gt;This is an Error for Demo Purposes&lt;/strong&gt; &lt;slot /&gt; &lt;/div&gt;&lt;/template&gt; 12345678910&lt;!-- Demo.vue 父组件 --&gt;&lt;script setup&gt;import AlertBox from './AlertBox.vue'&lt;/script&gt;&lt;template&gt; &lt;AlertBox&gt; Something bad happened. &lt;/AlertBox&gt;&lt;/template&gt; 父组件访问子组件实例父组件通过模板引用或者 $parent 链获取到的组件的公开实例，默认不会暴露任何在 &lt;script setup&gt; 中声明的绑定，我们可以通过 defineExpose 编译器宏来显式指定要暴露哪些绑定。 ex: 子组件显式暴漏绑定 123456789101112&lt;!-- Foo.vue --&gt;&lt;script setup&gt;import { ref } from 'vue'const a = 11const b = ref(2)const c = () =&gt; { console.log('im foo')}defineExpose({ a, b, c })&lt;/script&gt; 当父组件通过模板引用的方式获取到当前组件的实例，获取到的实例会像这样 { a: number, b: number } (ref 会和在普通实例中一样被自动解包) ex: 父组件通过模板引用访问子组件暴漏的绑定 123456789101112131415161718192021&lt;!-- Demo.vue --&gt;&lt;script setup&gt;import { ref } from 'vue';import Foo from './Foo.vue'; // setup 中 用 ref(null) 声明跟变量名同名的模板引用const fooRef = ref(); // &lt;Foo ref=&quot;fooRef&quot; /&gt;const abc = () =&gt; { // 通过模板引用获取实例暴变量值 // 注意：需要等到 mounted 后访问模板实例才有效 console.log(fooRef.value.a) // 11 fooRef.value.c()}&lt;/script&gt;&lt;template&gt; &lt;Foo ref=&quot;fooRef&quot; /&gt; &lt;!-- 在模板中可以直接用 $refs 访问模板引用，不需要声明 --&gt; &lt;p&gt;{{ $refs['fooRef'].a }}&lt;/p&gt;&lt;/template&gt; 子组件访问父组件方式1 使用 defineExpose父组件用 defineExpose() 显式暴露绑定后，在子组件的 &lt;script setup&gt; 中用 getCurrentInstance().parent.exposed 访问，在子组件的模板中用 $parent 访问。 推荐在子件的模板中调用父组件时使用该方式，在子组件的 &lt;script setup&gt; 中推荐用依赖注入更方便。 ex: 父组件引用子组件 12345678910111213141516&lt;!-- Demo.vue 父组件 --&gt;&lt;script setup&gt;import { ref } from 'vue';import Foo from './Foo.vue';const a = 111const bar = () =&gt; { console.log('im done.')}defineExpose({ a, bar }) // 显式暴露 bar 绑定&lt;/script&gt;&lt;template&gt; &lt;!-- 父组件引用子组件 --&gt; &lt;Foo ref=&quot;fooRef&quot; /&gt;&lt;/template&gt; ex: 子组件访问父组件显式暴露的绑定 12345678910111213&lt;!-- Foo.vue 子组件 --&gt;&lt;script setup&gt;import { getCurrentInstance } from 'vue';// 访问父组件 defineExpose() 暴漏的绑定const parentExposed = getCurrentInstance().parent.exposed;console.log(parentExposed.a)parentExposed.bar()&lt;/script&gt;&lt;template&gt; &lt;!-- 模板中直接用 $parent 就可以调用父组件暴漏的绑定 --&gt; {{ $parent.a }}&lt;/template&gt; 方式2 使用 Vue3 的依赖注入用 provide() 在父组件提供依赖，用 inject() 在子组件 &lt;script setup&gt; 中注入。 在 setup 中访问父组件，使用依赖注入更便捷。inject() 必须在组件的 setup() 阶段同步调用。 ex: 父组件提供依赖 12345678910111213&lt;!-- Demo.vue 父组件 --&gt;&lt;template&gt; &lt;Foo /&gt; &lt;/template&gt;&lt;script setup&gt;import { provide } from 'vue'import Foo from './Foo.vue';provide('bar', () =&gt; { console.log('Hello')})&lt;/script&gt; ex: 子组件注入依赖 123456&lt;!-- Foo.vue 子组件 --&gt;&lt;script setup&gt;import { inject } from 'vue';const abc = inject('bar');abc()&lt;/script&gt; 兄弟组件互相访问兄弟组件加上 ref 属性后，通过父组件的 refs 就可以调用到兄弟组件用 defineExpose() 暴漏的绑定， ex: 父组件显式暴漏绑定 123456789101112131415&lt;!-- Demo.vue 父组件 --&gt;&lt;template&gt; &lt;Foo ref=&quot;fooRef&quot; /&gt; &lt;/template&gt;&lt;script setup&gt;import Foo from './Foo.vue';const a = 1;const bar = () =&gt; { console.log('im bar')}defineExpose({ a, bar })&lt;/script&gt; ex: 子组件访问父组件暴漏的绑定 12345678910111213&lt;!-- Foo.vue 子组件 --&gt;&lt;script setup&gt;import { getCurrentInstance } from 'vue';const parent = getCurrentInstance().parent; // 获取父组件的模板引用parent.refs.fooRef.a // 调用暴漏的变量parent.refs.fooRef.bar() // 调用暴漏的方法&lt;/script&gt;&lt;template&gt; &lt;!-- 在模板中用预置的 $parent 访问覆膜板暴漏的绑定 --&gt; {{ $parent.refs.fooRef.a }} &lt;button @click=&quot;$parent.refs.fooRef.bar()&quot;&gt;点我&lt;/button&gt;&lt;/template&gt; 使用状态管理比较复杂的应用，强烈推荐使用该方法。我们可以用 响应式 API 做简单状态管理。 原理根据 js 变量的作用域的特性，在一个单页面应用（SPA）中，如果有一个文件定义了全局变量，SPA 中任意一个文件 import 该文件，都会共享该变量。代码如下： 123456// test.jslet a1 = 0;export function pr() { ++a1; console.log(a1)} 如果你有一部分状态需要在多个组件实例间共享，你可以使用 reactive() 或 ref() 来创建一个响应式对象，并将它导入到多个组件中： 123456789// todoListStore.jsimport { ref } from 'vue';export const todoList = ref([]);export function loadData() (list) { // 从服务器端加载数据 fetch('/todo').then(function (res) { todoList.value = res.json().items; })} 父组件或子组件都可以引入 todoListStore.js，共同维护其中的响应式变量 todoList 的状态。 更复杂的状态管理，推荐使用 Pinia。 使用 window 变量在组件中把变量赋值给 windows 变量，父组件、兄弟组件、子组件都能访问到，子组件 setup() 之外也能访问到。此方法违背了 Vue3 的设计思想，容易引起混乱，慎用。","link":"/front-end/vue3-component-transfer-value.html"},{"title":"Vue3（单文件组件 + &lt;script setup&gt; + 组合式 API）组件实例常用内置属性、方法、函数","text":"本文总结 Vue3 组件实例在模板中暴露的常用公共属性和方法，以及对应的 组合式 API 函数。 $data/$props/$options 属性在 组合式 API 下几乎用不到。$el 不建议用。$slots 表示父组件所传入插槽的一个对象，很少用，有兴趣可查看官方文档。 $parent模板中用 $parent 获取父组件实例，可访问父组件用 defineExpose() 显式暴露的绑定。 组合式 API 先在 setup 中用 getCurrentInstance() 获取到当前组件实例，再用 parent 属性访问父组件。getCurrentInstance().parent 除了能访问父组 defineExpose() 暴漏的绑定外，能访问父组件更多的属性和方法，多用于组件的开发，在应用开发中一般不建议用。 12345import { getCurrentInstance } from 'vue';const parent = getCurrentInstance().parent; // 获取父组件的实例parent.exposed // 访问父组件 defineExpose() 暴露的绑定parent.refs // 父组件中的模板引用，在模板中用 $parent.refs 为未定义 getCurrentInstance() 只在 setup 中调用才能获取到正确的值。 $root模板中通过 $root 变量访问根实例用 defineExpose() 显式暴露的绑定。组合式 API 对应为 getCurrentInstance().root。 $refs组件实例的模板引用。组合式 API 用 ref(null) 赋值给一个模板引用名同名的变量得到实例。 123456789101112&lt;script setup&gt;import { ref } from 'vue';const inputRef = ref(); // 这样就可以用 inputRef 访问 MyComponent 显式暴露的绑定了。&lt;/script&gt;&lt;template&gt; &lt;MyComponent ref=&quot;inputRef&quot; /&gt; &lt;!-- 模板中用 $refs 访问模板实例 --&gt; {{ $refs.inputRef.xxx }}&lt;/template&gt; $emit()组合式 API 开发中，在模板中可以用 $emit() 触发事件，触发前需要先用 defineEmits() 声明事件。在 setup 中用声明事件编译器宏 defineEmits() 返回的函数来触发事件。 123456789101112&lt;script setup&gt;const emt = defineEmits(['ev-1', 'ev-2'])function myHandler() { emt('ev-2')}&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;$emit('ev-1')&quot;&gt; click &lt;/button&gt; &lt;button @click=&quot;myHandler&quot;&gt; click &lt;/button&gt;&lt;/template&gt;","link":"/front-end/vue-sfc-script-setup-component-instance.html"},{"title":"在 Vue3 &lt;script setup&gt; + 组合式 API 之 怎用使用响应式变量","text":"什么是响应式？Vue3 的响应式是：当更改响应式对象的值改变时，视图会随即自动更新。 ref()ref() 返回一个响应式对象，可以用 value 属性来访问或更改对象的值。ref 对象在模板中会自动解包，用变量名不需要加 .value 就能访问。 1234567891011&lt;script setup&gt;import { ref } from 'vue';const say = ref('hi'); // 定义值为 hi 的响应式变量 saysay.value = 'hello'; // 把 say 的值改为 hello&lt;/script&gt;&lt;template&gt; &lt;!-- 自动解包，不需要些成 {{ say.value }} --&gt; &lt;p&gt;{{ say }}&lt;/p&gt;&lt;/template&gt; reactive()用 reactive() 函数可以创建一个响应式对象，可以用对象的属性来访问对象，也可以使用 Object.assign() 来改变对象。 123456789101112131415161718&lt;script setup&gt;import { reactive } from 'vue'const state = reactive({ count: 0 })Object.assign(state, {count: 9}); // 用 Object.assign 更改，使用时应注意，Object.assign 为覆盖式浅拷贝值。function increment() { state.count++}&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt; {{ state.count }} &lt;/button&gt;&lt;/template&gt; reactive() 仅对 对象类型 有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。 readonly()readonly() 返回一个原值的只读代理对象。 ref()/reactive/非响应式变量该怎样选择？响应式需要实时监听变量的状态，是需要系统开销的，所以不应该所有的变量都用响应式。当页面因响应式变量变动而刷新时（包括隐藏、显示），很多时候非响应式变量值改动了也会跟着变，但并不是100%。只要涉及到模板跟着实时更新的变量，都应该用响应式变量，反之则应该用飞响应式变量。 当变量改动后，模板视图不需要跟着变的时候，不需要用响应式变量。 当需要响应式，并且要覆盖全部的值来更改的时候，使用 ref，如列表数组、原始类型等。 当值为对象（对象、数组、Map、Set 等集合类型）类型的时候，用 reactive。 参考1、响应式基础2、深入响应式系统3、响应式API：核心","link":"/front-end/vue3-sfc-composition-script-setup-reactivity.html"},{"title":"在 Vue3 单文件组件中使用 &lt;script setup&gt; + 组合式 API","text":"&lt;script setup&gt; 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。当同时使用 SFC 与组合式 API 时该语法是默认推荐。 基本语法在 &lt;script&gt; 标签上添加 setup 属性启用该语法，里面的代码会背编译成组件 setup() 函数的内容，每次组件实例被创建时执行。 123&lt;script setup&gt;// 组合式 API 写在这里&lt;/script&gt; 如果要使用 TypeScript，加上 lang=&quot;ts&quot; 属性即可。 12&lt;script lang=&quot;ts&quot; setup&gt;&lt;/script&gt; 当使用 &lt;script setup&gt; 的时候，任何在 &lt;script setup&gt; 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用。 响应式响应式即变量数据变化的时候，视图跟着变化。响应式状态需要明确使用 响应式 API 来创建.常用 API： ref() reactive() computed() watch() watchEffect() readonly() 模板引用实例在 &lt;script setup&gt; 中可通过 ref(null) 函数声明 ref 同名常量，可获取模板引用实例 123456789101112131415&lt;template&gt; &lt;input ref=&quot;input&quot; /&gt;&lt;/template&gt;&lt;script setup&gt;import { ref, onMounted } from 'vue'// 声明一个 ref 来存放该元素的引用// 必须和模板里的 ref 同名const input = ref(null)onMounted(() =&gt; { input.value.focus()})&lt;/script&gt; 组件使用组件&lt;script setup&gt; 里的值也能被直接作为自定义组件的标签名使用： 12345678&lt;template&gt; &lt;MyComponent /&gt; 推荐使用 PascalCase 格式以保持和变量保持一致。 &lt;my-component&gt;也可以用 kebab-case 格式的标签&lt;/my-component&gt;&lt;/template&gt;&lt;script setup&gt;import MyComponent from './MyComponent.vue'&lt;/script&gt; 动态组件用 :is 绑定动态组件 123456789&lt;template&gt; &lt;component :is=&quot;Foo&quot; /&gt; &lt;component :is=&quot;someCondition ? Foo : Bar&quot; /&gt;&lt;/template&gt;&lt;script setup&gt;import Foo from './Foo.vue'import Bar from './Bar.vue'&lt;/script&gt; 递归组件一个单文件组件可以通过它的文件名被其自己所引用。例如：名为 FooBar.vue 的组件可以在其模板中用 &lt;FooBar /&gt; 引用它自己。 1234567891011121314&lt;!-- FooBar.vue --&gt;&lt;template&gt; &lt;!-- 递归显示分类及其子分类 --&gt; &lt;ul v-for=&quot;category in categories&quot;&gt; &lt;li&gt; {{ category.title }} &lt;FooBar v-if=&quot;category.children&quot; :categories=&quot;category.children&quot;&gt;&lt;/FooBar&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; defineProps(['categories'])&lt;/script&gt; 命名空间组件可以使用带 . 的组件标签，例如 &lt;Foo.Bar&gt; 来引用嵌套在对象属性中的组件。这在需要从单个文件中导入多个组件的时候非常有用： 123456789&lt;script setup&gt;import * as Form from './form-components'&lt;/script&gt;&lt;template&gt; &lt;Form.Input&gt; &lt;Form.Label&gt;label&lt;/Form.Label&gt; &lt;/Form.Input&gt;&lt;/template&gt; 通过插槽来分配内容我们使用 &lt;slot&gt; 作为一个占位符，父组件传递进来的内容就会渲染在这里。 1234567&lt;!-- AlertBox.vue --&gt;&lt;template&gt; &lt;div class=&quot;alert-box&quot;&gt; &lt;strong&gt;This is an Error for Demo Purposes&lt;/strong&gt; &lt;slot /&gt; &lt;/div&gt;&lt;/template&gt; 12345&lt;template&gt; &lt;AlertBox&gt; Something bad happened. &lt;/AlertBox&gt;&lt;/template&gt; 具名插槽： 1&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; 引用具名组件： 1234567&lt;template v-slot:header&gt;&lt;!-- header 插槽的内容放这里 --&gt;&lt;/template&gt;简写：&lt;template #header&gt;&lt;!-- header 插槽的内容放这里 --&gt;&lt;/template&gt; 使用自定义指令&lt;script setup&gt; 中自定义的指令不需要显式注册就可以直接使用。 12345678910&lt;script setup&gt;const vMyDirective = { beforeMount: (el) =&gt; { // 在元素上做些操作 }}&lt;/script&gt;&lt;template&gt; &lt;h1 v-my-directive&gt;...&lt;/h1&gt;&lt;/template&gt; defineProps() 和 defineEmits() defineProps() 用来声明属性 defineEmits() 用来声明事件 defineProps() 和 defineEmits() 是编译器宏，不需要导入，并且只能在 &lt;script setup&gt; 中使用。 1234567891011121314151617181920212223&lt;script setup&gt;const props = defineProps({ foo: String})// 在 &lt;script setup&gt; 中可使用 defineProps() 返回值变量访问自定义属性console.log(props.foo)// 组件声明事件后，还需要触发事件，才能让事件起作用。const emits = defineEmits(['change', 'delete'])const onDelete = () =&gt; { // 在 &lt;script setup&gt; 中可以用 defineEmits() 返回值变量触发事件。 emits('delete')}&lt;/script&gt;&lt;template&gt; &lt;p&gt;{{ foo }}&lt;/p&gt; &lt;!-- template 中可以用预置变量 $emit 触发声明的变量 --&gt; &lt;input @keyup=&quot;$emit('change')&quot; /&gt; &lt;button @click=&quot;onDelete&quot;&gt;删除&lt;/button&gt;&lt;/template&gt; defineProps() 默认值非 ts 我们可以用 default 来设置默认值，ts 需要用 withDefaults 编译器宏。 12345678910&lt;script setup&gt;// 非 ts 声明属性的默认值defineProps({ msg: { type: String, default: 'hello', required: false }});&lt;/script&gt; 12345678910&lt;script setup lang=&quot;ts&quot;&gt;export interface Props { msg?: string}// TypeScript 使用 withDefaults 编译器宏const props = withDefaults(defineProps&lt;Props&gt;(), { msg: 'hello'})&lt;/script&gt; defineExpose()通过模板引用或者 $parent 链获取到的组件的公开实例，默认不会暴露任何在 &lt;script setup&gt; 中声明的绑定。可以通过 defineExpose 编译器宏来显式指定在 &lt;script setup&gt; 组件中要暴露出去的绑定。 更详细的内容前往《组件间互相访问》，包含组件父组件访问子组件、子组件访问父组件、兄弟组件互相访问。 限制&lt;script setup&gt; 标签不能加 src 属性。 参考 Vue &lt;script setup&gt; 文档 Vue 官方文档 Vue API参考","link":"/front-end/vue3-sfc-composition-script-setup.html"},{"title":"VueRouter 后退页面刷新问题解决方案","text":"用 VueRouter hash 模式时，点击浏览器上的后退按钮，浏览器显示上一次浏览页面的时候，会重新执行页面，像页面刷新一样。 跟微信小程序不一样，微信小程序后退的时候不会重新执行，只是给我们一个 onShow 事件，这样如果需要刷新数据，我们就可以在 onShow 里面解决。 解决方案1：用 keep-alive 组件使用 Vue 内置的 keep-alive 组件。使用该组件后，可缓存组件状态， 页面二次显示时，触发 onActivated 事件，我们可在 onActivated 中决定是否刷新列表数据。此方法解决比较完美，但是稍微复杂，并发性能要求较高时，推荐使用该方案。 第1步，修改 router-view 标签把 &lt;router-view&gt;&lt;/router-view&gt; 改为： 123456&lt;router-view v-slot=&quot;{ Component, route }&quot;&gt; &lt;keep-alive&gt; &lt;component :is=&quot;Component&quot; v-if=&quot;route.meta.keepAlive&quot; /&gt; &lt;/keep-alive&gt; &lt;component :is=&quot;Component&quot; v-if=&quot;!route.meta.keepAlive&quot; /&gt;&lt;/router-view&gt; 用 keep-alive 需要注意的是：组件第一次打开加载数据渲染页面，第二次打开时，不管你是点击链接还是前进后退到该组件，都是触发 onActivated、onDeactivated 事件，而不会重新执行&amp;渲染页面，因此需要手动检测数据更新时重新加载数据。 第2步，路由设置在需要保持状态的页面的路由上加上 meta.keepAlive = true 参数，如 1{ path: '/orders', component: () =&gt; import('./pages/order/Index.vue'), meta: { keepAlive: true } } 第3步，数据有更新则刷新列表数据详情页更改后，标记数据已更改，然后再在列表页检测数据是否变更，变更则刷新数据。 12345678&lt;!-- pages/order/Index.vue --&gt;&lt;script setup&gt;import { onActivated } from 'vue';// 加上 keep-alive 组件后，路由组件增加 activated 事件，页面显示时触发。onActivated(() =&gt; { // 检测列表数据否已更改，更改则刷新数据});&lt;/script&gt; 解决方案2：把请求参数同步到 hash 后的查询参数并发要求不高的可用此方法，简单。 修改 hash 的查询串，页面不会被刷新。如果列表页有请求参数变化时，可修改 URL hash，把请求参数替换到 hash 后面的查询串，页面加载时根据请求参数请求服务器数据。这样就完全不用检查列表数据是否已更新，还能保证数据实时性，唯一美中不足的是，后退还要重新请求服务器数据、重新渲染页面。 1234567891011axios.get('/admin/users', query, (resp) =&gt; { // 更新列表数据 Object.assign(data, resp.data); // 请求参数转换成查询串字符串 const queryString = new URLSearchParams(query).toString(); // 取得去掉查询串后的 URL hash const hash = window.location.hash.replace(/(.*?)\\?.*/, '$1'); // 更新 URL hash 后面的查询串 window.location.hash = hash + '?' + queryString;}); 解决方案3：把子页面封装成模态窗子组件列表页的新建、编辑、查看详情可做成 模态窗 方式，不存在后退到列表页的情况，自然就不用担心页面重新执行的问题，而且用户体验还更好。如果表单页面比较复杂，再使用前面的方案。 注意：数据更新后注意刷新列表数据。新建、编辑后都需要刷新列表数据，因此建议在父组件（列表页）暴露刷新数据的方法，再在新建、编辑组件中回调。 实现1 使用 expose在子组件的 setup 中用 getCurrentInstance().parent.exposed 可以访问父组件用 defineExpose 暴露的绑定。 编辑用户组件（页面）： 123456789101112131415161718192021222324252627282930313233343536&lt;!-- user/Edit.vue --&gt;&lt;script setup&gt;import { ref, reactive, getCurrentInstance } from 'vue';const parentExposed = getCurrentInstance().parent.exposed; // 父组件暴露的绑定const isShow = ref(false);const user = reactive({});const onClose = () =&gt; { isShow.value = false;};const show = (id) =&gt; { isShow.value = true // 根据 ID 获取远程数据 ... Object.assign(user, 服务器返回数据);}const save = () =&gt; { // 提交数据 ... // 更新列表数据 parentExposed.reloadData();}// 暴漏 show 方法defineExpose({ show });&lt;/script&gt;&lt;template&gt;&lt;el-dialog v-model=&quot;isShow&quot; title=&quot;编辑&quot; @close=&quot;onClose&quot;&gt; {{ user.id }} ... &lt;input v-model=&quot;item.name&quot; /&gt; &lt;button @click=&quot;save&quot;&gt;保存&lt;/button&gt; &lt;/el-dialog&gt;&lt;/template&gt; 列表组件（父），引用编辑用户信息组件（子） 1234567891011121314151617181920212223242526272829&lt;!-- user/Index.vue --&gt;&lt;script setup&gt;import { ref } from 'vue'; import Edit from './Edit.vue';const editRef = ref(); // Edit 组件的模板引用实例const users = [ {id: 1, name: '老王'}, {id: 2, name: '老李'},];const reloadData = () =&gt; { // 重新加载数据}defineExpose({ reloadData }); // reloadData 暴露出来，给子组件调用&lt;/script&gt;&lt;template&gt; &lt;!-- 引用子组件 --&gt; &lt;Edit ref=&quot;editRef&quot; /&gt; &lt;ul&gt; &lt;li v-for=&quot;user in users&quot;&gt; {{ user.name }} &lt;!-- 父组件调用 Edit 子组件的模板实例暴露的 show() --&gt; &lt;button @click=&quot;editRef.show(user.id)&quot;&gt;编辑&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 实现2：使用依赖注入 方案3的实现方案也可以用 依赖注入 实现，在父组件使用 provide 提供依赖，在子组件用 inject 注入上层组件提供的数据或方法。 在 setup 中访问父组件，使用依赖注入更便捷。在模板中访问上层组件，用 expose 更方便 12345678&lt;script setup&gt;// 子组件 Foo.vueimport { inject } from 'vue';const xyz = inject('abc');onMounted(() =&gt; { xyz();// 子组件执行父组件注入的 'abc'})&lt;/script&gt; 12345678910111213&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;Foo /&gt; &lt;/template&gt;&lt;script setup&gt;import { provide } from 'vue'import Foo from './Foo.vue';provide('abc', () =&gt; { console.log('Hello')})&lt;/script&gt;","link":"/front-end/vuerouter-refresh-on-back-solution.html"},{"title":"CentOS 下 Nginx 部署免费SSL安全证书 Let&#39;s Encrypt （certbot）","text":"关于Let’s EncryptLet’s Encrypt 是一个免费、开放，自动化的证书颁发机构，由 ISRG（Internet Security Research Group）运作。 兼容性： Let’s Encrypt 已经得了 IdenTrust 的交叉签名，这意味着其证书现在已经可以被所有主流的浏览器所信任，包括从IE6-IE11，其它现代浏览器更没话说，100%放心使用。 申请频率限制注册IP限制：每IP每3个小时不超过10次 域名数量限制：每个域名（包含子域名）每7天不超过5个 证书位置所有版本已申请的证书放在 /etc/letsencrypt/archive下，/etc/letsencrypt/live是指向最新版本的符号链接。web server中关于证书的配置建议指向 live 目录下的文件，以免证书更新后还需要更改配置。 每个域名一个目录，主要包含以下几个文件： cert.pem 申请的服务器证书文件 privkey.pem 服务器证书对应的私钥 chain.pem 除服务器证书外，浏览器解析所需的其他全部证书，比如根证书和中间证书 fullchain.pem 包含服务器证书的全部证书链文件 证书更新Let’s Encrypt 颁发的服务器证书有效期为90天，官方表示此为出于安全原因，降低错发证书，证书泄漏的危害。通过自动续期来解决有效期短的问题，官方建议每2个月更新证书。 如果到期没有更新证书，CA会向申请证书时提交的邮件地址发送提醒email。 自动续期可以使用 crontab 实现。注意更新证书后重启 web server ！ 生成证书通过官方提供的certbot工具生成证书 安装 certbot使用yum安装 1yum -y install certbot 如果安装不成功，可以用git克隆certbot源码来执行 12git clone https://github.com/certbot/certbotcd certbot 安装证书有多种方式，我们用绑定证书到站点目录的方式安装，这样更新证书时不需要停止nginx。 1certbot certonly --webroot -w /path/to/webroot/ -d yiba.fun -d www.yiba.fun --email cmpan@qq.com /path/to/webroot/ 为站点根目录，配置时域名必须是可访问的。 123456789# 监听443端口listen 443 default ssl;# 启用 sslssl on;ssl_certificate /etc/letsencrypt/live/yiba.fun/fullchain.pem;ssl_certificate_key /etc/letsencrypt/live/yiba.fun/privkey.pem;ssl_protocols TLSv1 TLSv1.1 TLSv1.2 SSLv3;ssl_prefer_server_ciphers on; 常见问题1）IE6打不开ssl_protocols 增加SSLv3参数即可，IE6的安全设置中默认不勾选 TLS 协议。 2）第一次执行letsencrypt-auto需要安装需要的关联包，需要等待的时间比较长，甚至更新系统关联包后执行脚本不成功，再执行一次就行。 3）免费版本不支持通授权域名使用通配符 12# 不支持使用 * 通配符-d *.yiba.fun","link":"/misc/nginx-ssl-lets-encrypt.html"},{"title":"使用 CentOS 服务器 ssh 做 socks5 代理","text":"服务器端添加账号服务器端 ssh 禁用了密码登录，配置 key 登录，添加用户名为 pxy 的账号，只允许作为代理，不允许做其它操作。 使用 root 权限操作 123456useradd pxy -g nobody -s /bin/false -mmkdir /home/pxy/.sshcd /home/pxy/.sshvim authorized_keys# 输入客户端shh公钥chown pxy:nobody -R /home/pxy 设置本地 ssh 连接创建本地秘钥（名称为pxy_rsa） 1234567vim ~/.ssh/config # 添加内容Host pxyHostName 47.240.48.52Port 22User pxyIdentityFile ~/.ssh/pxy_rsa 3、客户端执行命令 1ssh pxy -D 1080 -N 这样在本地就可以使用 localhost:1080 做代理了。可以设置系统的全局代理设置来使用代理。 在 Mac 系统，如果只启用命令行窗口的代理，启动 ssh 代理后，执行命令： 1234# 打开代理export all_proxy=socks5://127.0.0.1:1080# 关闭代理unset all_proxy 可以用命令 curl ipinfo.io 查看当前公网 IP 信息。","link":"/misc/centos-ssh-socks5.html"},{"title":"PhpStorm 快捷键","text":"文件 option + command + y 同步文件/文件夹，文件夹中外部新增或删除文件时刷新有延迟，使用该快捷键同步 Ctrl + n 新建文件/文件夹 编辑 command + x 剪切行 command + c 复制行/复制选中文本 command + shift + c 复制文件/文件夹路径 command + d 复制行 option + ↑ 选择更多代码 option + ↓ 选择更少代码 option + → 下一个代码（令牌）位置 option + ← 上一个代码（令牌）位置 command + → 代码行尾 command + ← 代码行头 tab 增加缩进 shift + tab 减少缩进 command + shift + enter 完成代码声明 查找相关 command + f 查找当前文件 command + r 查找替换 command + shift + o 快速查询文件 command + shift + f 关键字查找,更强大的查询器 command + shift + r 高级替换 command + option + b 找到当前类（接口的）所有继承（实现类） option + shift + c 查找最近修改的文件 option + f7 直接查询选中的字符 ctrl + f7 文件中查询选中字符 command + 鼠标点击 跳到类或方法或变量等声明处 command + shift + tab 切换tab页文件 command + shift + +,- 展开或缩起 command + . 折叠或展开选中的代码 View command + e 打开最近的文件 shift + command + e 最近打开文件具体代码位置 Bookmarks F3 加入/取消书签 option + F3 加入(可设置数字字母记号的)/取消书签 command + F3 弹窗显示/隐藏书签 Code shift + command + ↑ 声明段上移 shift + command + ↓ 声明段下移 shift + option + ↑ 行上移 shift + option + ↓ 行下移 自动代码 option + 回车 选中类名/接口名后按快捷键，导入包，自动修正 command + n 快速生成代码，为每个成员属性生成 getter/setter/__construct/方法、文档注释、单元测试等 ctrl + i 快速生成插入魔术方法 ctrl + o 复写父类方法 command + option + l 对当前文件进行格式化排版 command + d 复制当前行 command + / // 单行注释 command + shift + / 多行注释 显示窗口 command + 1 Project command + 2 Favorites command + 6 TODO command + 7 Structure command + 9 Version Control 版本控制 option + F12 Terminal 终端 Git ctrl + v 版本控制相关操作 option + command + a Add option + command + z revert (取消Add) shift + command + p pull shift + command + k push command + k commit","link":"/misc/phpstorm-keyboard-shortcuts.html"},{"title":"解决 vim 粘贴内容缩进错乱问题","text":"平时经常用vim编辑服务器端一些配置文件和脚本，当复制粘贴内容时，会因为自动缩进把代码缩进搞乱了。 解决办法：进入粘贴模式粘贴内容1:set paste 我们不能直接通过修改配置来适应粘贴内容，因为粘贴模式下配置变化： 1234567891011121314textwidth = 0wrapmargin = 0set noaiset nosisofttabstop = 0revins 重置ruler 重置showmatch 重置formatoptions 使用空值# 下面的选项值不变，但却被禁用：lispindentexprcindent","link":"/misc/vim-paste.html"},{"title":"Composer 包下载加速","text":"Composer的元数据存在国外的服务器，每次执行composer命令的时候，经常要下载很多的元数据，需要几分钟到十几分钟，效率极低。 我们可以设置使用国内composer镜像来加速。阿里云composer镜像稳定且快速，推荐首选。 设置命令： 1composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 恢复默认源： 1composer config -g --unset repos.packagist","link":"/php/composer-speed.html"},{"title":"Laravel Eloquent 数据库关联查询","text":"Eloquent子查询1234567User::query()-&gt;whereIn( 'id', UserRolePivot::query() -&gt;select('user_id') -&gt;where('role_id', $roleId))-&gt;get();// SELECT * FROM user WHERE id IN( SELECT user_id FROM user_role_pivot WHERE role_id = $roleId) 分组查询 12345678User::query()-&gt;where('verified', 1)-&gt;where(function ($query) use ($keyword) { $query-&gt;where('name', 'like', &quot;%{$keyword}%&quot;) -&gt;orWhere('email', 'like', &quot;%{$keyword}%&quot;) -&gt;orWhere('mobile', 'like', &quot;%{$keyword}%&quot;);})-&gt;get();// SELECT * FROM user WHERE verified = 1 AND (name LIKE '%{$keyword}%' OR email LIKE '%{$keyword}%' OR mobile LIKE '%{$keyword}%')","link":"/php/laravel-eloquent-database-relate-query.html"},{"title":"Laravel Eloquent 数据库关联模型的增删改操作","text":"Laravel Eloquent ORM 提供了数据模型关联表操作的 API，熟练掌握这些API后，才体会到 Laravel 数据库操作有多高效。 一、hasMany 一对多关联save/saveMany 创建关联记录12345678910111213141516// 新建一条数据 Post 的评论，save 将自动添加 post_id 字段$comment = new Comment(['message' =&gt; 'A new comment.']);$post = Post::find(1);$post-&gt;comments()-&gt;save($comment);// 保持多条记录$post-&gt;comments()-&gt;saveMany([ new Comment(['message' =&gt; 'A new comment.']), new Comment(['message' =&gt; 'Another new comment.']),]);// 更新后需要重新加载模型及其关联，才会加到 $post-&gt;comments 中$post-&gt;refresh();// 所有评论，包括新保存的评论...$post-&gt;comments; create/createMany 创建关联记录和 save/saveMany 的区别是参数时数组，而不是模型。 1234567891011121314use App\\Models\\Post;$post = Post::find(1);$comment = $post-&gt;comments()-&gt;create([ 'message' =&gt; 'A new comment.',]);$post = Post::find(1);$post-&gt;comments()-&gt;createMany([ ['message' =&gt; 'A new comment.'], ['message' =&gt; 'Another new comment.'],]); push 递归保存模型和关联数据保持模型同时，保存其关联数据。 例：保存 Post 模型及其评论和评论作者 123456$post = Post::find(1);$post-&gt;comments[0]-&gt;message = 'Message';$post-&gt;comments[0]-&gt;author-&gt;name = 'Author Name';$post-&gt;push(); 二、Belongs To （一对多反向）属于关联123456789101112use App\\Models\\Account;$account = Account::find(10);// associate 将子模型分配给新的父模型$user-&gt;account()-&gt;associate($account);// dissociate 从子模型中删除父模型，将关联外键设置为 null$user-&gt;account()-&gt;dissociate();$user-&gt;save(); 三、多对多关联attach 创建多对多关联记录用于新建时。 12345678910// 创建多对多关联记录$user-&gt;roles()-&gt;attach($roleId);$user-&gt;roles()-&gt;attach([1, 2, 3]);// 可以附加中间表字段数据$user-&gt;roles()-&gt;attach($roleId, ['expires' =&gt; $expires]);$user-&gt;roles()-&gt;attach([1 =&gt; ['expires' =&gt; $expires], 2, 3]);$user-&gt;roles()-&gt;attach([ 1 =&gt; ['expires' =&gt; $expires], 2 =&gt; ['expires' =&gt; $expires],]); detach 删除中间表关联记录用于删除时。 12345678// 移除用户的一个角色...$user-&gt;roles()-&gt;detach($roleId);// 移除用户的多个角色$user-&gt;roles()-&gt;detach([1, 2, 3]);// 移除用户的所有角色...$user-&gt;roles()-&gt;detach(); sync 同步关联用于修改模型时。 中间表记录中，所有未在 ID 数组中的记录都将会被移除，在数组中的可更新。 123456789$user-&gt;roles()-&gt;sync([1, 2, 3]);$user-&gt;roles()-&gt;sync([1 =&gt; ['expires' =&gt; true], 2, 3]);// $user-&gt;roles()-&gt;syncWithPivotValues([1 =&gt; ['active' =&gt; true], 2 =&gt; ['active' =&gt; true], 3 =&gt; ['active' =&gt; true]]) 的简写$user-&gt;roles()-&gt;syncWithPivotValues([1, 2, 3], ['active' =&gt; true]);// 同步但不移除现有的关联 ID$user-&gt;roles()-&gt;syncWithoutDetaching([1, 2, 3]); toggle 切换关联关联表中有则删除，无则新建。 1$user-&gt;roles()-&gt;toggle([1, 2, 3]); 四、更新父级时间戳当一个模型属 belongsTo 或者 belongsToMany 另一个模型时， 例如 Comment 属于 Post ，当 Comment 模型被更新时，你需要自动「触发」父级 Post 模型的 updated_at 时间戳的更新。Eloquent 让它变得简单，只要在子模型加一个包含关联名称的 touches 属性即可： 1234567891011121314151617181920namespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model{ /** * 需要触发的所有关联关系。 */ protected $touches = ['post']; /** * 评论所属文章。 */ public function post() { return $this-&gt;belongsTo(Post::class); }} 参考 Laravel 9 中文文档","link":"/php/laravel-eloquent-pivot-read-write.html"},{"title":"PhpStorm + Xdebug 远程调试PHP","text":"这篇文章解决： PhpStorm + xdebug 单步调试PHP的设置 远程服务器PHP源码调试 微信公众号接口/小程序接口服务的调试 有些应用需要部署到外网环境才能运行，我们使用 PhpStorm + Xdebug 在本地调试远程web服务器跑的代码。 安装xdebug扩展1pecl install xdebug 如果服务器部署的是php很新，安装xdebug不成功，可以试试 pecl install xdebug-beta 配置xdebug在php.ini中添加如下配置 12345678910111213141516171819202122232425[xdebug]zend_extension = xdebug.soxdebug.remote_enable = On; 单步调试的IDE所在主机xdebug.remote_host = &quot;192.168.1.167&quot;; IDE调试器监听端口，mac下和php-fpm端口冲突，自行更改该端口xdebug.remote_port = 9000xdebug.remote_handler = &quot;dbgp&quot;; 自动连接调试IDExdebug.remote_autostart = 1; 如果启用，则忽略 xdebug.remote_host设置， 不管哪里请求，都是回调所请求的IP（即xdebug.remote_host动态设置为请求IP）xdebug.remote_connect_back = 0xdebug.auto_trace = 1xdebug.collect_includes = 1xdebug.collect_params = 1xdebug.collect_return = 1xdebug.default_enable = 1xdebug.collect_assignments = 1xdebug.collect_vars = 1xdebug.show_local_vars = 1xdebug.show_exception_trace = 0xdebug.profiler_enable = 1xdebug.profiler_output_dir = &quot;/temp/xdebug&quot;xdebug.profiler_output_name = cachegrind.out.%R%uxdebug.trace_format = 2 设置ide监听xdebug调试端口打开 PhpStorm 设置： 12345# windowsFile &gt; Settings &gt; Languages &amp;&amp; Frameworks &gt; PHP &gt; Debug# macPhpStorm &gt; Preferences... &gt; Languages &amp;&amp; Frameworks &gt; PHP &gt; Debug 设置xdebug的调试端口跟php.ini中一致的调试端口。 启动监听调试点击 “Start Listening”图标启动监听调试（图标右边挂个电话的图标）。不想调试的时候停止监听即可。 调试给要调试的脚本加断点，浏览服务器上要调试的页面（URL），即可再本地IDE中调试。 注意事项调试 swoole 应用的时候，IDE要先启动调试监听，然后再启动 swoole 应用服务，再浏览网址进行监听。因为cli模式下运行脚本时才启动调试，而php-fpm或mod_php每次浏览PHP页面的时候都会发起调试，因此启动调试监听后刷新页面即可调试。调试器可能不会在首行停下了，因此需要加断点后再调试。 微信公众号接口不好调试吗？我们可以结合路由器的端口映射 + 动态域名解析，使用这个配置方式就可以调试了。","link":"/php/php-remote-debug-phpstorm-xdebug.html"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"箭头函数","slug":"箭头函数","link":"/tags/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Element-UI","slug":"Element-UI","link":"/tags/Element-UI/"},{"name":"prototype","slug":"prototype","link":"/tags/prototype/"},{"name":"call","slug":"call","link":"/tags/call/"},{"name":"apply","slug":"apply","link":"/tags/apply/"},{"name":"bind","slug":"bind","link":"/tags/bind/"},{"name":"Class","slug":"Class","link":"/tags/Class/"},{"name":"Object","slug":"Object","link":"/tags/Object/"},{"name":"组合式API","slug":"组合式API","link":"/tags/%E7%BB%84%E5%90%88%E5%BC%8FAPI/"},{"name":"响应式","slug":"响应式","link":"/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"VueRouter","slug":"VueRouter","link":"/tags/VueRouter/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Certbot","slug":"Certbot","link":"/tags/Certbot/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"Let&#39;s Encrypt","slug":"Let-s-Encrypt","link":"/tags/Let-s-Encrypt/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"Socks5","slug":"Socks5","link":"/tags/Socks5/"},{"name":"PhpStorm","slug":"PhpStorm","link":"/tags/PhpStorm/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"Composer","slug":"Composer","link":"/tags/Composer/"},{"name":"Laravel","slug":"Laravel","link":"/tags/Laravel/"},{"name":"Eloquent","slug":"Eloquent","link":"/tags/Eloquent/"},{"name":"Xdebug","slug":"Xdebug","link":"/tags/Xdebug/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"Vue","slug":"前端/Vue","link":"/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"杂记","slug":"杂记","link":"/categories/%E6%9D%82%E8%AE%B0/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"Laravel","slug":"PHP/Laravel","link":"/categories/PHP/Laravel/"}],"pages":[{"title":"关于","text":"我是伊爸，一个大龄全栈码农。 PHP/Go Laravel/Hyperf Gin/Beego MySQL/Mongo TS/ES/Vue/ElementPlus SCSS/Bootstrap/Tailwind","link":"/about/index.html"}]}